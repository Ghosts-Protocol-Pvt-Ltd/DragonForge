#!/bin/bash
# ============================================================================
# DragonForge â€” System Detection & Setup
# ============================================================================
# Detects IOMMU groups, GPU devices, and validates system readiness for
# GPU passthrough. Can also install the hook and configure VFIO.
#
# Usage:
#   ./dragonforge detect     â€” Detect GPU, IOMMU groups, system info
#   ./dragonforge setup      â€” Install hook + configure VFIO modules
#   ./dragonforge status     â€” Check current passthrough state
#   ./dragonforge vm-create  â€” Create the Windows 11 VM
#   ./dragonforge vm-start   â€” Start the VM
#   ./dragonforge vm-stop    â€” Gracefully stop the VM
#   ./dragonforge vm-kill    â€” Force stop the VM
#   ./dragonforge vm-viewer  â€” Open SPICE viewer
#   ./dragonforge uninstall  â€” Remove hook and VFIO config
# ============================================================================

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")" && pwd)"
VERSION="2.0.0"

# â”€â”€ Colors â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
BOLD='\033[1m'
DIM='\033[2m'
NC='\033[0m'

print_banner() {
    echo -e "${CYAN}"
    echo "  â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
    echo "  â•‘            ðŸ‰ DragonForge v${VERSION}              â•‘"
    echo "  â•‘      GPU Passthrough Toolkit                 â•‘"
    echo "  â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo -e "${NC}"
}

info()    { echo -e "  ${BLUE}â–¸${NC} $1"; }
success() { echo -e "  ${GREEN}âœ“${NC} $1"; }
warn()    { echo -e "  ${YELLOW}âš ${NC} $1"; }
error()   { echo -e "  ${RED}âœ—${NC} $1"; }
header()  { echo -e "\n  ${BOLD}${CYAN}â”€â”€ $1 â”€â”€${NC}\n"; }

# â”€â”€ Anti-Detection Helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

# Generate random alphanumeric string
generate_random_string() {
    local length="${1:-8}"
    head -c 100 /dev/urandom | tr -dc 'A-Z0-9' | head -c "$length"
}

# Generate realistic MAC address using real hardware vendor OUIs
# Avoids 52:54:00 (QEMU/KVM), 00:16:3E (Xen), 00:0C:29 (VMware)
generate_mac() {
    # Real-world OUI prefixes: Intel, Realtek, Intel
    local -a oui_list=("00:1B:21" "3C:22:FB" "80:EE:73" "A4:83:E7" "F8:75:A4" "00:E0:4C" "D8:BB:C1")
    local idx=$(( $(od -An -tu4 -N4 /dev/urandom | tr -d ' ') % ${#oui_list[@]} ))
    local oui="${oui_list[$idx]}"
    local b4=$(( $(od -An -tu1 -N1 /dev/urandom | tr -d ' ') ))
    local b5=$(( $(od -An -tu1 -N1 /dev/urandom | tr -d ' ') ))
    local b6=$(( $(od -An -tu1 -N1 /dev/urandom | tr -d ' ') ))
    printf '%s:%02X:%02X:%02X' "$oui" "$b4" "$b5" "$b6"
}

# Generate disk serial matching Samsung NVMe patterns
generate_disk_serial() {
    printf 'S%s' "$(generate_random_string 11)"
}

# Generate HyperV vendor ID â€” random 12 chars, avoids all known hypervisor signatures
generate_vendor_id() {
    local id
    while true; do
        id=$(head -c 100 /dev/urandom | tr -dc 'A-Za-z0-9' | head -c 12)
        local id_lower
        id_lower=$(echo "$id" | tr '[:upper:]' '[:lower:]')
        case "$id_lower" in
            *kvmkvm*|*microsoft*|*vmware*|*xenvmm*|*acrn*|*genuineintel*|*authenticamd*) continue ;;
            *) break ;;
        esac
    done
    echo "$id"
}

# Detect GPU driver type for a PCI device
detect_gpu_driver() {
    local gpu_bdf="$1"
    local vendor_id
    vendor_id=$(cat "/sys/bus/pci/devices/$gpu_bdf/vendor" 2>/dev/null | sed 's/^0x//' | tr '[:upper:]' '[:lower:]')

    case "$vendor_id" in
        10de)
            # NVIDIA â€” prefer nvidia proprietary, fallback nouveau
            if [ -d "/sys/bus/pci/drivers/nvidia" ]; then
                echo "nvidia"
            elif [ -d "/sys/bus/pci/drivers/nouveau" ]; then
                echo "nouveau"
            else
                echo "nvidia"  # assume nvidia will be installed
            fi
            ;;
        1002)
            # AMD â€” prefer amdgpu, fallback radeon
            if [ -d "/sys/bus/pci/drivers/amdgpu" ]; then
                echo "amdgpu"
            elif [ -d "/sys/bus/pci/drivers/radeon" ]; then
                echo "radeon"
            else
                echo "amdgpu"  # assume amdgpu will be available
            fi
            ;;
        *)
            echo "unknown"
            ;;
    esac
}

# Classify GPU as integrated or discrete
classify_gpu() {
    local gpu_bdf="$1"
    local vendor_id device_id
    vendor_id=$(cat "/sys/bus/pci/devices/$gpu_bdf/vendor" 2>/dev/null | sed 's/^0x//' | tr '[:upper:]' '[:lower:]')
    device_id=$(cat "/sys/bus/pci/devices/$gpu_bdf/device" 2>/dev/null | sed 's/^0x//' | tr '[:upper:]' '[:lower:]')
    local desc
    desc=$(lspci -s "${gpu_bdf#0000:}" 2>/dev/null || echo "")

    # Intel integrated GPUs (UHD, Iris, etc.)
    if [ "$vendor_id" = "8086" ]; then
        echo "integrated"
        return
    fi

    # AMD APU integrated GPUs (Vega, Raphael, Phoenix, etc.)
    if [ "$vendor_id" = "1002" ]; then
        if echo "$desc" | grep -qiE "Raphael|Phoenix|Rembrandt|Barcelo|Cezanne|Renoir|Picasso|Raven|Vega.*\bGfx\b"; then
            echo "integrated"
            return
        fi
        # If on bus 00 or in same IOMMU group as root complex, likely integrated
        local bus
        bus=$(echo "$gpu_bdf" | cut -d: -f2)
        if [ "$bus" = "00" ] || [[ "$bus" =~ ^0[0-5]$ ]]; then
            # Could be integrated if the description doesn't match discrete patterns
            if ! echo "$desc" | grep -qiE "Radeon RX|Navi|RDNA|Polaris|Vega 56|Vega 64"; then
                echo "integrated"
                return
            fi
        fi
    fi

    # NVIDIA is always discrete (no NVIDIA integrated GPUs on x86)
    # AMD with RX/Navi/discrete identifiers
    echo "discrete"
}

# â”€â”€ Auto-generate Config â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

auto_generate_config() {
    local conf="$SCRIPT_DIR/config/dragonforge.conf"

    # Already exists â€” nothing to do
    if [ -f "$conf" ]; then
        return 0
    fi

    header "Auto-generating Config"
    info "No config found â€” detecting hardware..."

    # â”€â”€ Universal GPU Detection â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # Scan ALL GPUs, classify as integrated vs discrete, pick discrete for passthrough
    local gpu_bdf="" gpu_vendor="" gpu_device="" gpu_driver=""
    local igpu_bdf="" igpu_desc=""

    while IFS= read -r line; do
        local bdf desc
        bdf=$(echo "$line" | awk '{print $1}')
        desc=$(echo "$line" | cut -d' ' -f2-)

        # Normalize to full domain format
        if [[ ! "$bdf" =~ ^[0-9a-fA-F]{4}: ]]; then
            bdf="0000:$bdf"
        fi

        # Skip if sysfs doesn't have this device
        [ -d "/sys/bus/pci/devices/$bdf" ] || continue

        local classification
        classification=$(classify_gpu "$bdf")

        if [ "$classification" = "discrete" ] && [ -z "$gpu_bdf" ]; then
            gpu_bdf="$bdf"
            gpu_vendor=$(cat "/sys/bus/pci/devices/$bdf/vendor" 2>/dev/null | sed 's/^0x//')
            gpu_device=$(cat "/sys/bus/pci/devices/$bdf/device" 2>/dev/null | sed 's/^0x//')
            gpu_driver=$(detect_gpu_driver "$bdf")
            success "Discrete GPU: $bdf [$gpu_vendor:$gpu_device] ($desc)"
            info "  Driver: $gpu_driver"
        elif [ "$classification" = "integrated" ] && [ -z "$igpu_bdf" ]; then
            igpu_bdf="$bdf"
            igpu_desc="$desc"
            info "Integrated GPU: $bdf ($desc) â€” will stay with host"
        fi
    done < <(lspci -Dnn 2>/dev/null | grep -iE "VGA|3D|Display" || true)

    if [ -z "$gpu_bdf" ]; then
        error "No discrete GPU found for passthrough"
        if [ -n "$igpu_bdf" ]; then
            info "Only found integrated GPU at $igpu_bdf"
        fi
        info "DragonForge requires a system with 2 GPUs (integrated + discrete)"
        info "Create config/dragonforge.conf manually if detection is wrong"
        return 1
    fi

    if [ -z "$igpu_bdf" ]; then
        warn "No integrated GPU detected â€” host will lose display during passthrough"
        info "Consider using a second monitor or SSH access"
    fi

    # Find matching audio device (same bus, function .1)
    local bus_prefix="${gpu_bdf%.*}"
    local gpu_audio_bdf="${bus_prefix}.1"
    local audio_vendor="" audio_device=""
    if [ -d "/sys/bus/pci/devices/$gpu_audio_bdf" ]; then
        audio_vendor=$(cat "/sys/bus/pci/devices/$gpu_audio_bdf/vendor" 2>/dev/null | sed 's/^0x//')
        audio_device=$(cat "/sys/bus/pci/devices/$gpu_audio_bdf/device" 2>/dev/null | sed 's/^0x//')
        success "Found GPU Audio: $gpu_audio_bdf [$audio_vendor:$audio_device]"
    else
        gpu_audio_bdf=""
        warn "No GPU audio device found at ${bus_prefix}.1 â€” edit config manually"
    fi

    # Detect total RAM, allocate half for VM (rounded to nearest GB, capped at 16G min 4G)
    local total_ram_kb
    total_ram_kb=$(awk '/MemTotal/{print $2}' /proc/meminfo)
    local vm_ram_mb=$(( (total_ram_kb / 2 / 1024 / 1024) * 1024 ))  # round down to nearest GB
    if [ "$vm_ram_mb" -gt 16384 ]; then vm_ram_mb=16384; fi
    if [ "$vm_ram_mb" -lt 4096 ]; then vm_ram_mb=4096; fi

    # Detect CPU threads, allocate half for VM (min 2)
    local total_threads
    total_threads=$(nproc)
    local vm_cpus=$(( total_threads / 2 ))
    if [ "$vm_cpus" -lt 2 ]; then vm_cpus=2; fi

    # Find Windows ISO
    local win_iso=""
    for search_dir in "$HOME/Downloads" "$HOME" "/tmp"; do
        local found
        found=$(find "$search_dir" -maxdepth 2 -iname "Win11*.iso" -o -iname "Win10*.iso" 2>/dev/null | head -1)
        if [ -n "$found" ]; then
            win_iso="$found"
            break
        fi
    done

    # Find VirtIO ISO
    local virtio_iso=""
    for search_dir in "$HOME/Downloads" "$HOME" "/tmp"; do
        local found
        found=$(find "$search_dir" -maxdepth 2 -iname "virtio-win*.iso" 2>/dev/null | head -1)
        if [ -n "$found" ]; then
            virtio_iso="$found"
            break
        fi
    done

    # Write config
    mkdir -p "$SCRIPT_DIR/config"
    cat > "$conf" <<CONFEOF
# ============================================================================
# DragonForge Configuration â€” Auto-generated $(date +%Y-%m-%d)
# ============================================================================
# Edit these values if anything looks wrong.
# Run 'dragonforge detect' to see full hardware details.
# ============================================================================

# â”€â”€ VM Settings â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

VM_NAME="win11-dragonforge"
VM_RAM_MB="$vm_ram_mb"
VM_CPUS="$vm_cpus"
VM_DISK_SIZE="128G"
VM_DISK_PATH="/var/lib/libvirt/images/win11-dragonforge.qcow2"

# â”€â”€ GPU Settings â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

GPU_PCI="$gpu_bdf"
GPU_AUDIO="${gpu_audio_bdf:-EDIT_ME}"

GPU_VENDOR_ID="$gpu_vendor"
GPU_DEVICE_ID="$gpu_device"
GPU_AUDIO_VENDOR_ID="${audio_vendor:-$gpu_vendor}"
GPU_AUDIO_DEVICE_ID="${audio_device:-EDIT_ME}"

# GPU driver for host rebind after VM shutdown (auto-detected)
# nvidia, nouveau, amdgpu, radeon
GPU_DRIVER="$gpu_driver"

# â”€â”€ ISO Paths â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

WIN_ISO_PATH="${win_iso:-/path/to/Win11.iso}"
VIRTIO_ISO_PATH="${virtio_iso:-/path/to/virtio-win.iso}"

# â”€â”€ Hardware Health â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

DRAGONFORGE_HOOK_TIMEOUT="30"
DRAGONFORGE_GPU_TEMP_MAX="85"
CONFEOF

    success "Config written to config/dragonforge.conf"

    # Report what was detected vs what needs manual editing
    if [ -n "$win_iso" ]; then
        success "Windows ISO: $win_iso"
    else
        warn "No Windows ISO found â€” edit WIN_ISO_PATH in config"
    fi
    if [ -n "$virtio_iso" ]; then
        success "VirtIO ISO: $virtio_iso"
    else
        warn "No VirtIO ISO found â€” edit VIRTIO_ISO_PATH in config"
    fi

    echo ""
    return 0
}

# â”€â”€ Load Config Helper â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

load_config() {
    local conf="$SCRIPT_DIR/config/dragonforge.conf"

    # Auto-generate if missing
    if [ ! -f "$conf" ]; then
        auto_generate_config || {
            error "Cannot proceed without config"
            exit 1
        }
    fi

    source "$conf"
}

# â”€â”€ Detect â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

cmd_detect() {
    print_banner
    header "System Information"

    # OS
    if [ -f /etc/os-release ]; then
        source /etc/os-release
        info "OS: ${BOLD}$NAME $VERSION${NC}"
    fi

    # Kernel
    info "Kernel: ${BOLD}$(uname -r)${NC}"

    # CPU
    local cpu_model
    cpu_model=$(grep -m1 "model name" /proc/cpuinfo | cut -d: -f2 | xargs)
    info "CPU: ${BOLD}$cpu_model${NC}"

    # RAM
    local total_ram
    total_ram=$(free -h | awk '/Mem:/{print $2}')
    info "RAM: ${BOLD}$total_ram${NC}"

    # QEMU
    if command -v qemu-system-x86_64 &>/dev/null; then
        local qemu_ver
        qemu_ver=$(qemu-system-x86_64 --version | head -1 | grep -oP '\d+\.\d+(\.\d+)?' | head -1)
        success "QEMU: $qemu_ver"
    else
        error "QEMU not found"
    fi

    # Libvirt
    if command -v virsh &>/dev/null; then
        local virsh_ver
        virsh_ver=$(virsh --version)
        success "Libvirt: $virsh_ver"
    else
        error "Libvirt not found"
    fi

    # virt-viewer
    if command -v virt-viewer &>/dev/null; then
        success "virt-viewer: installed"
    else
        warn "virt-viewer: not found (install for SPICE display)"
    fi

    # IOMMU
    header "IOMMU Status"

    # Check sysfs first (doesn't need root), then dmesg as fallback
    if [ -d /sys/class/iommu ] && [ -n "$(ls -A /sys/class/iommu 2>/dev/null)" ]; then
        success "IOMMU is enabled"
        local group_count
        group_count=$(find /sys/kernel/iommu_groups -maxdepth 1 -mindepth 1 -type d 2>/dev/null | wc -l)
        info "IOMMU groups found: ${BOLD}$group_count${NC}"
    elif dmesg 2>/dev/null | grep -qi "IOMMU enabled\|DMAR:.*IOMMU\|Adding to iommu group"; then
        success "IOMMU is enabled (detected via dmesg)"
    else
        error "IOMMU does not appear to be enabled"
        info "Add 'intel_iommu=on iommu=pt' (Intel) or 'amd_iommu=on iommu=pt' (AMD) to kernel params"
    fi

    # VFIO modules
    header "VFIO Modules"

    for mod in vfio vfio_pci vfio_iommu_type1; do
        if lsmod | grep -q "^${mod//-/_}"; then
            success "$mod: loaded"
        else
            warn "$mod: not loaded"
        fi
    done

    # GPU detection
    header "GPU Devices"

    echo -e "  ${DIM}Scanning for NVIDIA/AMD discrete GPUs...${NC}"
    echo ""

    local gpu_found=0
    while IFS= read -r line; do
        local bdf desc
        bdf=$(echo "$line" | awk '{print $1}')
        desc=$(echo "$line" | cut -d' ' -f2-)

        # Normalize to full domain format
        local sysfs_bdf="$bdf"
        if [[ ! "$bdf" =~ ^[0-9a-fA-F]{4}: ]]; then
            sysfs_bdf="0000:$bdf"
        fi

        local vendor_id device_id
        vendor_id=$(cat "/sys/bus/pci/devices/$sysfs_bdf/vendor" 2>/dev/null | sed 's/^0x//')
        device_id=$(cat "/sys/bus/pci/devices/$sysfs_bdf/device" 2>/dev/null | sed 's/^0x//')

        # Classify GPU
        local gpu_class gpu_drv
        gpu_class=$(classify_gpu "$sysfs_bdf")
        gpu_drv=$(detect_gpu_driver "$sysfs_bdf")

        local class_label
        if [ "$gpu_class" = "integrated" ]; then
            class_label="${BLUE}[integrated â€” host display]${NC}"
        else
            class_label="${GREEN}[discrete â€” passthrough candidate]${NC}"
        fi

        echo -e "  ${GREEN}â–º${NC} ${BOLD}$bdf${NC} $class_label"
        echo -e "    $desc"
        echo -e "    ${DIM}Vendor:Device = $vendor_id:$device_id  |  Driver: $gpu_drv${NC}"

            # IOMMU group
            local iommu_group
            iommu_group=$(basename "$(readlink "/sys/bus/pci/devices/$sysfs_bdf/iommu_group" 2>/dev/null)" 2>/dev/null)
            if [ -n "$iommu_group" ]; then
                echo -e "    ${DIM}IOMMU Group: $iommu_group${NC}"

                # List other devices in same group
                local group_members
                group_members=$(find "/sys/kernel/iommu_groups/$iommu_group/devices/" -maxdepth 1 -mindepth 1 -printf '%f ' 2>/dev/null)
                echo -e "    ${DIM}Group members: $group_members${NC}"
            fi

            echo ""
            gpu_found=1
    done < <(lspci -Dnn 2>/dev/null | grep -iE "VGA|3D|Display" || true)

    # Also show audio devices that accompany GPUs
    echo ""
    while IFS= read -r line; do
        local bdf desc
        bdf=$(echo "$line" | awk '{print $1}')
        desc=$(echo "$line" | cut -d' ' -f2-)
        if echo "$desc" | grep -qiE "nvidia|radeon|amd.*audio"; then
            echo -e "  ${DIM}  ðŸ”Š $bdf â€” $desc${NC}"
        fi
    done < <(lspci -Dnn 2>/dev/null | grep -i "Audio" || true)

    if [ "$gpu_found" -eq 0 ]; then
        warn "No discrete GPU found"
    fi

    # Summary
    header "Next Steps"
    info "Run ${BOLD}dragonforge setup${NC} â€” config is auto-generated from detected hardware"
    info "Then ${BOLD}dragonforge create${NC} to create the VM"
    info "Edit ${BOLD}config/dragonforge.conf${NC} if you need to tweak anything"
    echo ""
}

# â”€â”€ Status â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

cmd_status() {
    print_banner
    header "DragonForge Status"

    # Load config (auto-generates if missing)
    load_config

    local vm_name="${VM_NAME:-win11-dragonforge}"
    local gpu_pci="${GPU_PCI:-0000:01:00.0}"
    local gpu_audio="${GPU_AUDIO:-0000:01:00.1}"

    info "VM Name: ${BOLD}$vm_name${NC}"
    info "GPU PCI: ${BOLD}$gpu_pci${NC}"
    info "GPU Audio: ${BOLD}$gpu_audio${NC}"

    # VM state
    header "VM State"
    local vm_state
    vm_state=$(sudo virsh domstate "$vm_name" 2>/dev/null | head -1 || echo "undefined")
    vm_state=$(echo "$vm_state" | tr -d '[:space:]')  # trim whitespace
    if [ -z "$vm_state" ]; then vm_state="undefined"; fi

    if [ "$vm_state" = "running" ]; then
        success "VM is running"
    elif [ "$vm_state" = "shutoff" ]; then
        info "VM is shut off"
    elif [ "$vm_state" = "undefined" ]; then
        warn "VM not created yet â€” run './dragonforge vm-create'"
    else
        warn "VM state: $vm_state"
    fi

    # GPU driver
    header "GPU Driver State"
    for dev in $gpu_pci $gpu_audio; do
        local driver
        driver=$(basename "$(readlink "/sys/bus/pci/devices/$dev/driver" 2>/dev/null)" 2>/dev/null)
        if [ "$driver" = "vfio-pci" ]; then
            info "$dev â†’ ${YELLOW}vfio-pci${NC} (passthrough mode)"
        elif [ -n "$driver" ]; then
            info "$dev â†’ ${GREEN}$driver${NC} (host mode)"
        else
            warn "$dev â†’ no driver"
        fi
    done

    # Hook installed?
    header "Installation"
    if sudo test -x /etc/libvirt/hooks/qemu 2>/dev/null; then
        success "Hook installed at /etc/libvirt/hooks/qemu"
    else
        warn "Hook not installed"
    fi

    if [ -f /etc/modules-load.d/dragonforge-vfio.conf ] || [ -f /etc/modules-load.d/vfio.conf ]; then
        success "VFIO modules configured for boot"
    else
        warn "VFIO module autoload not configured"
    fi

    echo ""
}

# â”€â”€ Setup â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

cmd_setup() {
    print_banner
    header "Installing DragonForge"

    # Check root
    if [ "$EUID" -ne 0 ]; then
        error "Setup must be run as root (use sudo)"
        exit 1
    fi

    # Load config (auto-generates if missing)
    load_config

    # Validate config
    if [ -z "${GPU_PCI:-}" ] || [ -z "${GPU_AUDIO:-}" ] || [ -z "${GPU_VENDOR_ID:-}" ] || [ -z "${GPU_DEVICE_ID:-}" ]; then
        error "Incomplete config. Required: GPU_PCI, GPU_AUDIO, GPU_VENDOR_ID, GPU_DEVICE_ID"
        exit 1
    fi

    # Install hook
    info "Installing libvirt hook..."
    local hook_src="$SCRIPT_DIR/hooks/qemu"
    if [ ! -f "$hook_src" ]; then
        error "Hook script not found: $hook_src"
        exit 1
    fi

    mkdir -p /etc/libvirt/hooks
    cp "$hook_src" /etc/libvirt/hooks/qemu
    chmod +x /etc/libvirt/hooks/qemu
    success "Hook installed"

    # Set up environment for hook (so it reads our config)
    cat > /etc/libvirt/hooks/dragonforge.env <<ENVEOF
# DragonForge GPU passthrough config â€” auto-generated
DRAGONFORGE_VM_NAME=$VM_NAME
DRAGONFORGE_GPU_PCI=$GPU_PCI
DRAGONFORGE_GPU_AUDIO=$GPU_AUDIO
DRAGONFORGE_GPU_DRIVER=${GPU_DRIVER:-nvidia}
ENVEOF
    success "Hook environment configured"

    # Patch hook to source env file
    if ! grep -q "dragonforge.env" /etc/libvirt/hooks/qemu; then
        sed -i '2i\\n# Source DragonForge config\nif [ -f /etc/libvirt/hooks/dragonforge.env ]; then source /etc/libvirt/hooks/dragonforge.env; fi' /etc/libvirt/hooks/qemu
    fi

    # VFIO module autoload (modules only â€” NO device IDs)
    # The hook handles dynamic bind/unbind per VM start/stop.
    # Loading vfio modules at boot ensures they're available when the hook needs them.
    info "Configuring VFIO modules for boot..."
    cat > /etc/modules-load.d/dragonforge-vfio.conf <<EOF
# DragonForge â€” VFIO modules for GPU passthrough
# Modules loaded at boot so the hook can bind devices dynamically.
# Device binding is handled by the libvirt hook, NOT by static vfio-pci ids.
vfio-pci
vfio
vfio_iommu_type1
EOF
    success "VFIO modules will load at boot"

    # Remove any static vfio-pci device binding (conflicts with dynamic hook approach)
    # Static binding (options vfio-pci ids=...) grabs the GPU at boot, preventing
    # the host from using it. The hook-based approach lets the host use the GPU
    # normally and only detaches it when the VM starts.
    if [ -f /etc/modprobe.d/dragonforge-vfio.conf ]; then
        rm -f /etc/modprobe.d/dragonforge-vfio.conf
        success "Removed static VFIO PCI binding (hook handles this dynamically)"
    fi
    info "GPU stays on nvidia until VM start â€” hook handles passthrough dynamically"

    # Ensure required packages
    header "Checking Dependencies"
    local deps_ok=1
    for cmd in qemu-system-x86_64 virsh virt-viewer swtpm swtpm_setup; do
        if command -v "$cmd" &>/dev/null; then
            success "$cmd: found"
        else
            warn "$cmd: not found"
            deps_ok=0
        fi
    done

    if [ "$deps_ok" -eq 0 ]; then
        echo ""
        info "Install missing packages:"
        info "  Fedora:  sudo dnf install qemu-kvm libvirt virt-manager virt-viewer swtpm swtpm-tools edk2-ovmf"
        info "  Arch:    sudo pacman -S qemu-full libvirt virt-manager virt-viewer swtpm edk2-ovmf"
        info "  Ubuntu:  sudo apt install qemu-kvm libvirt-daemon virt-manager virt-viewer swtpm swtpm-tools ovmf"
    fi

    # Create symlink so 'dragonforge' works from anywhere
    local symlink_target="/usr/local/bin/dragonforge"
    local script_path
    script_path=$(realpath "$SCRIPT_DIR/dragonforge")
    if [ -L "$symlink_target" ] || [ -e "$symlink_target" ]; then
        rm -f "$symlink_target"
    fi
    ln -s "$script_path" "$symlink_target"
    success "Symlink: dragonforge â†’ $script_path"

    # Restart libvirtd
    info "Restarting libvirtd..."
    systemctl restart libvirtd
    success "libvirtd restarted"

    header "Setup Complete"
    success "DragonForge is installed"
    info "You can now run ${BOLD}dragonforge${NC} from anywhere"
    info "Reboot to apply VFIO module changes, then run:"
    info "  ${BOLD}dragonforge create${NC}  â€” Create a Windows VM"
    info "  ${BOLD}dragonforge start${NC}   â€” Start the VM"
    echo ""
}

# â”€â”€ VM Create â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

cmd_vm_create() {
    print_banner
    header "Creating VM (Stealth Mode)"

    # Load config (auto-generates if missing)
    load_config

    local vm_name="${VM_NAME:-win11-dragonforge}"
    local vm_ram="${VM_RAM_MB:-16384}"
    local vm_cpus="${VM_CPUS:-8}"
    local disk_size="${VM_DISK_SIZE:-128G}"
    local disk_path="${VM_DISK_PATH:-/var/lib/libvirt/images/${vm_name}.qcow2}"
    local win_iso="${WIN_ISO_PATH:-}"
    local virtio_iso="${VIRTIO_ISO_PATH:-}"

    # Validate
    if [ -z "$win_iso" ] || [ ! -f "$win_iso" ]; then
        error "Windows ISO not found: $win_iso"
        info "Set WIN_ISO_PATH in config/dragonforge.conf"
        exit 1
    fi

    if [ -z "$virtio_iso" ] || [ ! -f "$virtio_iso" ]; then
        warn "VirtIO ISO not found â€” not needed for stealth mode (using SATA)"
        virtio_iso=""
    fi

    # Create disk
    if [ ! -f "$disk_path" ]; then
        info "Creating ${disk_size} qcow2 disk..."
        sudo qemu-img create -f qcow2 "$disk_path" "$disk_size"
        success "Disk created: $disk_path"
    else
        warn "Disk already exists: $disk_path"
    fi

    # Check swtpm (required for Windows 11 TPM 2.0)
    if ! command -v swtpm &>/dev/null; then
        error "swtpm not found â€” required for Windows 11 TPM 2.0"
        info "  Fedora:  sudo dnf install swtpm swtpm-tools"
        info "  Arch:    sudo pacman -S swtpm"
        info "  Ubuntu:  sudo apt install swtpm swtpm-tools"
        exit 1
    fi
    success "swtpm: found"

    # Find OVMF firmware â€” CODE and VARS must be the same size variant.
    # Windows 11 requires Secure Boot with Microsoft keys pre-enrolled.
    # 4M variants include TPM2 (Tcg2Dxe) drivers â€” REQUIRED for TPM support.
    # 2M variants do NOT include TPM2 drivers and Windows will say "TPM 2.0 not found".
    local ovmf_code="" ovmf_src="" ovmf_format="raw"
    local ovmf_vars=""
    local -a firmware_pairs=(
        # Fedora 4M SecureBoot qcow2 (preferred â€” includes TPM2 drivers)
        "/usr/share/edk2/ovmf/OVMF_CODE_4M.secboot.qcow2:/usr/share/edk2/ovmf/OVMF_VARS_4M.secboot.qcow2:qcow2"
        # Fedora 4M SecureBoot raw
        "/usr/share/edk2/ovmf/OVMF_CODE_4M.secboot.fd:/usr/share/edk2/ovmf/OVMF_VARS_4M.secboot.fd:raw"
        # Fedora 2M SecureBoot (NO TPM2 drivers â€” avoid if possible)
        "/usr/share/edk2/ovmf/OVMF_CODE.secboot.fd:/usr/share/edk2/ovmf/OVMF_VARS.secboot.fd:raw"
        # Ubuntu/Debian 4M SecureBoot
        "/usr/share/OVMF/OVMF_CODE_4M.secboot.fd:/usr/share/OVMF/OVMF_VARS_4M.secboot.fd:raw"
        "/usr/share/OVMF/OVMF_CODE_4M.ms.fd:/usr/share/OVMF/OVMF_VARS_4M.ms.fd:raw"
        # Ubuntu/Debian 2M SecureBoot
        "/usr/share/OVMF/OVMF_CODE.secboot.fd:/usr/share/OVMF/OVMF_VARS.secboot.fd:raw"
        "/usr/share/OVMF/OVMF_CODE.ms.fd:/usr/share/OVMF/OVMF_VARS.ms.fd:raw"
        # Fallback non-SecureBoot (Windows 11 will likely reject this)
        "/usr/share/edk2/ovmf/OVMF_CODE_4M.fd:/usr/share/edk2/ovmf/OVMF_VARS_4M.fd:raw"
        "/usr/share/edk2/ovmf/OVMF_CODE_4M.qcow2:/usr/share/edk2/ovmf/OVMF_VARS_4M.qcow2:qcow2"
        "/usr/share/edk2/ovmf/OVMF_CODE.fd:/usr/share/edk2/ovmf/OVMF_VARS.fd:raw"
        "/usr/share/OVMF/OVMF_CODE.fd:/usr/share/OVMF/OVMF_VARS.fd:raw"
    )
    for pair in "${firmware_pairs[@]}"; do
        local code vars fmt
        code=$(echo "$pair" | cut -d: -f1-2)  # handle paths with colons
        # Actually split on the known delimiter pattern
        IFS=: read -r code vars fmt <<< "$pair"
        if [ -f "$code" ] && [ -f "$vars" ]; then
            ovmf_code="$code"
            ovmf_src="$vars"
            ovmf_format="${fmt:-raw}"
            break
        fi
    done

    if [ -z "$ovmf_code" ] || [ -z "$ovmf_src" ]; then
        error "No OVMF firmware found. Install edk2-ovmf."
        info "  Fedora:  sudo dnf install edk2-ovmf"
        info "  Arch:    sudo pacman -S edk2-ovmf"
        info "  Ubuntu:  sudo apt install ovmf"
        exit 1
    fi

    success "OVMF CODE: $ovmf_code (format: $ovmf_format)"

    # Set VARS destination path based on format
    if [ "$ovmf_format" = "qcow2" ]; then
        ovmf_vars="/var/lib/libvirt/images/${vm_name}_VARS.qcow2"
    else
        ovmf_vars="/var/lib/libvirt/images/${vm_name}_VARS.fd"
    fi

    sudo cp "$ovmf_src" "$ovmf_vars"
    success "OVMF VARS: $ovmf_src â†’ $ovmf_vars"

    if [[ "$ovmf_src" == *"secboot"* ]] || [[ "$ovmf_src" == *".ms."* ]]; then
        success "Secure Boot keys: pre-enrolled (Windows 11 compatible)"
    else
        warn "VARS template has no pre-enrolled Secure Boot keys"
        warn "Windows 11 may refuse to install â€” try installing edk2-ovmf with SecureBoot support"
    fi

    # â”€â”€ Anti-Detection: Generate Stealth Identifiers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    header "Anti-Detection Setup"

    local stealth_mac
    stealth_mac=$(generate_mac)
    success "MAC Address: $stealth_mac (real vendor OUI)"

    local stealth_disk_serial
    stealth_disk_serial=$(generate_disk_serial)
    success "Disk Serial: $stealth_disk_serial (Samsung NVMe pattern)"

    local stealth_vendor_id
    stealth_vendor_id=$(generate_vendor_id)
    success "HyperV Vendor ID: $stealth_vendor_id (randomized)"



    # Helper to parse PCI address into XML hostdev
    pci_hostdev_xml() {
        local pci_addr="$1"
        local guest_fn="${2:-0}"
        local multifunction="${3:-}"
        local domain bus slot function
        domain=$(echo "$pci_addr" | cut -d: -f1)
        bus=$(echo "$pci_addr" | cut -d: -f2)
        slot=$(echo "$pci_addr" | cut -d: -f3 | cut -d. -f1)
        function=$(echo "$pci_addr" | cut -d. -f2)
        local mf_attr=""
        if [ -n "$multifunction" ]; then
            mf_attr=" multifunction='on'"
        fi
        cat <<PCIEOF
    <hostdev mode='subsystem' type='pci' managed='yes'>
      <source>
        <address domain='0x${domain}' bus='0x${bus}' slot='0x${slot}' function='0x${function}'/>
      </source>
      <address type='pci' domain='0x0000' bus='0x06' slot='0x00' function='0x${guest_fn}'${mf_attr}/>
    </hostdev>
PCIEOF
    }

    # Generate VM XML
    header "Generating Stealth VM"

    # Compute CPU topology
    local topo_cores topo_threads
    if [ "$((vm_cpus % 2))" -eq 0 ] && [ "$vm_cpus" -gt 1 ]; then
        topo_cores=$((vm_cpus / 2))
        topo_threads=2
    else
        topo_cores=$vm_cpus
        topo_threads=1
    fi

    local xml_path
    xml_path=$(mktemp "/tmp/${vm_name}.XXXXXX.xml")

    cat > "$xml_path" <<XMLEOF
<domain type='kvm'>
  <name>$vm_name</name>
  <metadata>
    <dragonforge:vm xmlns:dragonforge="https://github.com/Ghosts-Protocol-Pvt-Ltd/DragonForge">
      <dragonforge:version>2.0.0</dragonforge:version>
    </dragonforge:vm>
  </metadata>
  <memory unit='MiB'>$vm_ram</memory>
  <currentMemory unit='MiB'>$vm_ram</currentMemory>
  <vcpu placement='static'>$vm_cpus</vcpu>
  <iothreads>1</iothreads>
  <os firmware='efi'>
    <type arch='x86_64' machine='q35'>hvm</type>
    <firmware>
      <feature enabled='yes' name='enrolled-keys'/>
      <feature enabled='yes' name='secure-boot'/>
    </firmware>
    <loader readonly='yes' secure='yes' type='pflash' format='$ovmf_format'>$ovmf_code</loader>
    <nvram template='$ovmf_src' templateFormat='$ovmf_format' format='$ovmf_format'>$ovmf_vars</nvram>
    <boot dev='cdrom'/>
    <boot dev='hd'/>
    <smbios mode='host'/>
  </os>
  <features>
    <acpi/>
    <apic/>
    <hyperv mode='custom'>
      <relaxed state='on'/>
      <vapic state='on'/>
      <spinlocks state='on' retries='8191'/>
      <vpindex state='on'/>
      <runtime state='on'/>
      <synic state='on'/>
      <stimer state='on'/>
      <frequencies state='on'/>
      <vendor_id state='on' value='$stealth_vendor_id'/>
    </hyperv>
    <kvm>
      <hidden state='on'/>
    </kvm>
    <vmport state='off'/>
    <smm state='on'/>
    <ioapic driver='kvm'/>
  </features>
  <cpu mode='host-passthrough' check='none' migratable='off'>
    <topology sockets='1' dies='1' clusters='1' cores='$topo_cores' threads='$topo_threads'/>
    <feature policy='disable' name='hypervisor'/>
  </cpu>
  <clock offset='localtime'>
    <timer name='rtc' tickpolicy='catchup'/>
    <timer name='pit' tickpolicy='delay'/>
    <timer name='hpet' present='no'/>
    <timer name='hypervclock' present='yes'/>
    <timer name='tsc' present='yes' mode='native'/>
  </clock>
  <on_poweroff>destroy</on_poweroff>
  <on_reboot>restart</on_reboot>
  <on_crash>destroy</on_crash>
  <pm>
    <suspend-to-mem enabled='no'/>
    <suspend-to-disk enabled='no'/>
  </pm>
  <devices>
    <emulator>/usr/bin/qemu-system-x86_64</emulator>

    <!-- SATA Disk (stealth: no "Red Hat VirtIO" in Device Manager) -->
    <disk type='file' device='disk'>
      <driver name='qemu' type='qcow2' cache='writeback' discard='unmap'/>
      <source file='$disk_path'/>
      <target dev='sda' bus='sata'/>
      <serial>$stealth_disk_serial</serial>
    </disk>

    <!-- Windows ISO -->
    <disk type='file' device='cdrom'>
      <driver name='qemu' type='raw'/>
      <source file='$win_iso'/>
      <target dev='sdb' bus='sata'/>
      <readonly/>
    </disk>

    <!-- VirtIO Drivers ISO (optional â€” for post-install driver setup) -->
$(if [ -n "$virtio_iso" ] && [ -f "$virtio_iso" ]; then
    echo "    <disk type='file' device='cdrom'>"
    echo "      <driver name='qemu' type='raw'/>"
    echo "      <source file='$virtio_iso'/>"
    echo "      <target dev='sdc' bus='sata'/>"
    echo "      <readonly/>"
    echo "    </disk>"
fi)

    <!-- Network: Intel e1000e (stealth: looks like built-in Intel I219) -->
    <interface type='network'>
      <mac address='$stealth_mac'/>
      <source network='default'/>
      <model type='e1000e'/>
    </interface>

    <!-- SPICE Display (for initial setup â€” connect with virt-viewer) -->
    <graphics type='spice' autoport='yes' listen='127.0.0.1'>
      <listen type='address' address='127.0.0.1'/>
    </graphics>
    <video>
      <model type='qxl' ram='65536' vram='65536' vgamem='16384' heads='1' primary='yes'/>
    </video>

    <!-- USB Controller -->
    <controller type='usb' model='qemu-xhci' ports='8'/>
    <input type='tablet' bus='usb'/>
    <input type='keyboard' bus='usb'/>

    <!-- TPM 2.0 (Windows 11 requirement â€” tpm-crb matches real hardware) -->
    <tpm model='tpm-crb'>
      <backend type='emulator' version='2.0'/>
    </tpm>

    <!-- GPU Passthrough -->
$(pci_hostdev_xml "$GPU_PCI" 0 on)
$(pci_hostdev_xml "$GPU_AUDIO" 1)

    <!-- Audio (through SPICE) -->
    <sound model='ich9'>
      <audio id='1'/>
    </sound>
    <audio id='1' type='spice'/>

    <!-- Watchdog (matches real Intel ICH9 chipset) -->
    <watchdog model='itco' action='reset'/>

    <!-- Stealth: No balloon (removes virtio-balloon from PCI enumeration) -->
    <memballoon model='none'/>

    <!-- Stealth: No virtio-rng (removes another VM fingerprint) -->
  </devices>
</domain>
XMLEOF

    success "Stealth VM XML generated: $xml_path"

    # â”€â”€ Anti-Detection Summary â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    header "Stealth Features"
    success "SMBIOS: Host passthrough ($(sudo dmidecode -s system-manufacturer 2>/dev/null) $(sudo dmidecode -s system-product-name 2>/dev/null))"
    success "KVM: Hidden from CPUID (hypervisor bit disabled)"
    success "HyperV: Random vendor ID ($stealth_vendor_id)"
    success "CPU: Host passthrough with hypervisor feature disabled"
    success "Disk: SATA (no VirtIO fingerprint) + realistic serial"
    success "Network: Intel e1000e (no VirtIO fingerprint) + real vendor MAC"
    success "Balloon: Disabled (no VirtIO balloon in PCI)"
    success "RNG: Disabled (no VirtIO RNG in PCI)"
    success "TSC: Native mode (reduces timing-based detection)"
    success "TPM 2.0: CRB model (matches real hardware)"
    success "Secure Boot: Enabled with pre-enrolled keys"

    # Define in libvirt
    header "Defining VM"
    if sudo virsh dominfo "$vm_name" &>/dev/null; then
        local cur_state
        cur_state=$(sudo virsh domstate "$vm_name" 2>/dev/null || true)
        if [ "$cur_state" = "running" ] || [ "$cur_state" = "paused" ]; then
            warn "VM is $cur_state â€” destroying first"
            sudo virsh destroy "$vm_name" 2>/dev/null || true
            sleep 1
        fi

        local old_uuid
        old_uuid=$(sudo virsh domuuid "$vm_name" 2>/dev/null || true)

        warn "VM '$vm_name' already defined â€” undefining (with NVRAM + TPM cleanup)"
        sudo virsh undefine "$vm_name" --nvram --tpm 2>/dev/null || true

        if [ -n "$old_uuid" ]; then
            local swtpm_dir="/var/lib/libvirt/swtpm"
            if [ -d "$swtpm_dir/$old_uuid" ]; then
                sudo rm -rf "$swtpm_dir/$old_uuid"
                info "Cleared swtpm state for $old_uuid"
            fi
        fi

        # Recopy OVMF VARS (undefine --nvram deleted the old one)
        # Also clean up any leftover VARS in the other format
        sudo rm -f "/var/lib/libvirt/images/${vm_name}_VARS.fd" 2>/dev/null || true
        sudo rm -f "/var/lib/libvirt/images/${vm_name}_VARS.qcow2" 2>/dev/null || true
        sudo cp "$ovmf_src" "$ovmf_vars"
    fi

    # Fix SELinux labels for TPM and OVMF files
    if command -v restorecon &>/dev/null; then
        sudo restorecon -F "$ovmf_vars" 2>/dev/null || true
        sudo restorecon -RF /var/lib/libvirt/swtpm/ 2>/dev/null || true
        success "SELinux labels restored for OVMF + swtpm"
    fi

    sudo virsh define "$xml_path"
    rm -f "$xml_path"
    success "VM defined: $vm_name"

    # Verify TPM state was created
    local new_uuid
    new_uuid=$(sudo virsh domuuid "$vm_name" 2>/dev/null || true)
    if [ -n "$new_uuid" ] && [ -d "/var/lib/libvirt/swtpm/$new_uuid" ]; then
        success "TPM state initialized (UUID: $new_uuid)"
    else
        info "TPM state will be created on first VM start"
    fi

    header "VM Created (Stealth Mode)"
    info "Start with:  ${BOLD}./dragonforge start${NC}"
    info "View with:   ${BOLD}./dragonforge viewer${NC}"
    echo ""
    local _mfg _prod
    _mfg=$(sudo dmidecode -s system-manufacturer 2>/dev/null || echo "your hardware")
    _prod=$(sudo dmidecode -s system-product-name 2>/dev/null || echo "")
    info "${DIM}After Windows install + NVIDIA driver setup, the VM will appear"
    info "as a genuine ${_mfg} ${_prod} to all software.${NC}"
    echo ""
}

# â”€â”€ VM Start â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

cmd_vm_start() {
    load_config
    local vm_name="${VM_NAME:-win11-dragonforge}"
    local gpu_pci="${GPU_PCI:-0000:01:00.0}"

    print_banner
    header "Starting VM"

    # Pre-flight checks
    if ! lsmod | grep -q "^vfio_pci"; then
        error "vfio_pci module not loaded"
        info "Run: sudo modprobe vfio-pci"
        info "Or reboot after running './dragonforge setup'"
        exit 1
    fi
    success "vfio_pci module loaded"

    # Check if VM is already running
    local state
    state=$(sudo virsh domstate "$vm_name" 2>/dev/null || echo "undefined")
    if [ "$state" = "running" ]; then
        warn "$vm_name is already running"
        info "Use './dragonforge vm-viewer' to connect"
        return 0
    fi

    # Check if GPU exists at PCI address
    if [ ! -d "/sys/bus/pci/devices/$gpu_pci" ]; then
        error "GPU not found at PCI address $gpu_pci"
        info "Run './dragonforge detect' to find the correct address"
        exit 1
    fi
    success "GPU found at $gpu_pci"

    # GPU temperature check
    if command -v nvidia-smi &>/dev/null; then
        local temp
        temp=$(nvidia-smi --query-gpu=temperature.gpu --format=csv,noheader,nounits 2>/dev/null | head -1)
        if [ -n "$temp" ] && [ "$temp" -gt 0 ] 2>/dev/null; then
            local temp_max="${DRAGONFORGE_GPU_TEMP_MAX:-85}"
            if [ "$temp" -ge "$temp_max" ]; then
                error "GPU temperature ${temp}Â°C exceeds safe limit ${temp_max}Â°C"
                info "Let the GPU cool down before starting the VM"
                exit 1
            fi
            success "GPU temperature: ${temp}Â°C (limit: ${temp_max}Â°C)"
        fi
    fi

    # Battery check for laptops
    local bat_path="/sys/class/power_supply/BAT0"
    if [ -d "$bat_path" ]; then
        local ac_status
        ac_status=$(cat /sys/class/power_supply/AC*/online 2>/dev/null | head -1)
        if [ "${ac_status:-1}" = "0" ]; then
            local capacity
            capacity=$(cat "$bat_path/capacity" 2>/dev/null || echo "unknown")
            warn "Running on battery (${capacity}%) â€” GPU passthrough drains battery fast"
            info "Plug in power for best experience"
        else
            success "AC power connected"
        fi
    fi

    # Check libvirtd is running
    if ! systemctl is-active --quiet libvirtd 2>/dev/null; then
        error "libvirtd is not running"
        info "Run: sudo systemctl start libvirtd"
        exit 1
    fi
    success "libvirtd is running"

    # Clean up stale QEMU domain directories from previous crashed sessions
    # This prevents SELinux master-key.aes label conflicts
    for stale_dir in /var/lib/libvirt/qemu/domain-*-"${vm_name}"; do
        if [ -d "$stale_dir" ]; then
            warn "Cleaning stale QEMU state: $stale_dir"
            sudo rm -rf "$stale_dir" 2>/dev/null || true
        fi
    done

    # Clean up stale swtpm processes and log files
    # Prevents SELinux label conflict: "Setting different SELinux label on ... which is already in use"
    local stale_swtpm_log="/var/log/swtpm/libvirt/qemu/${vm_name}-swtpm.log"
    if [ -f "$stale_swtpm_log" ]; then
        # Kill any orphaned swtpm processes using this log
        local swtpm_pids
        swtpm_pids=$(sudo fuser "$stale_swtpm_log" 2>/dev/null | tr -s ' ')
        if [ -n "$swtpm_pids" ]; then
            warn "Killing stale swtpm processes: $swtpm_pids"
            echo "$swtpm_pids" | xargs -r sudo kill -9 2>/dev/null || true
            sleep 1
        fi
        sudo rm -f "$stale_swtpm_log" 2>/dev/null || true
    fi

    info "Starting $vm_name..."
    if ! sudo virsh start "$vm_name" 2>&1; then
        error "Failed to start VM"
        info "Check: sudo journalctl -u libvirtd -n 20"
        info "Or try: ./dragonforge create  (to recreate VM definition)"
        exit 1
    fi
    success "$vm_name is running"

    echo ""
    info "Open viewer: ${BOLD}./dragonforge vm-viewer${NC}"
    info "Stop VM:     ${BOLD}./dragonforge vm-stop${NC}"
    echo ""
}

# â”€â”€ VM Stop â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

cmd_vm_stop() {
    load_config
    local vm_name="${VM_NAME:-win11-dragonforge}"
    local gpu_pci="${GPU_PCI:-0000:01:00.0}"

    # Check if VM is actually running
    local state
    state=$(sudo virsh domstate "$vm_name" 2>/dev/null || echo "undefined")
    if [ "$state" != "running" ]; then
        info "$vm_name is not running (state: $state)"
        return 0
    fi

    info "Shutting down $vm_name..."
    sudo virsh shutdown "$vm_name"
    info "Waiting for graceful shutdown (60s timeout)..."

    local i=0
    while [ "$i" -lt 60 ]; do
        if ! sudo virsh domstate "$vm_name" 2>/dev/null | grep -q "running"; then
            success "$vm_name has shut down"

            # Verify GPU returned to host
            sleep 3
            local driver
            driver=$(basename "$(readlink "/sys/bus/pci/devices/$gpu_pci/driver" 2>/dev/null)" 2>/dev/null)
            if [ -n "$driver" ] && [ "$driver" != "vfio-pci" ]; then
                success "GPU returned to host ($driver)"
            elif [ "$driver" = "vfio-pci" ]; then
                warn "GPU still on vfio-pci â€” hook release may have failed"
                info "Run: sudo dragonforge reset"
            else
                warn "GPU has no driver â€” may need PCI rescan"
                info "Run: sudo dragonforge reset"
            fi
            return 0
        fi
        sleep 1
        i=$((i + 1))
    done

    warn "VM did not shut down gracefully after 60s."
    info "Use './dragonforge vm-kill' to force stop."
}

# â”€â”€ VM Kill â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

cmd_vm_kill() {
    load_config
    local vm_name="${VM_NAME:-win11-dragonforge}"

    # Check if running first
    local state
    state=$(sudo virsh domstate "$vm_name" 2>/dev/null || echo "undefined")
    if [ "$state" != "running" ] && [ "$state" != "paused" ]; then
        info "$vm_name is not running (state: $state)"
        return 0
    fi

    warn "Force stopping $vm_name..."
    sudo virsh destroy "$vm_name"
    success "$vm_name forcefully stopped"
    info "GPU should return to host within a few seconds"
}

# â”€â”€ VM Viewer â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

cmd_vm_viewer() {
    load_config
    local vm_name="${VM_NAME:-win11-dragonforge}"

    # Check if VM is running
    local state
    state=$(sudo virsh domstate "$vm_name" 2>/dev/null || echo "undefined")
    if [ "$state" != "running" ]; then
        error "$vm_name is not running (state: $state)"
        info "Start it first: ./dragonforge vm-start"
        exit 1
    fi

    if ! command -v virt-viewer &>/dev/null; then
        error "virt-viewer not installed"
        info "Install: sudo dnf install virt-viewer"
        exit 1
    fi

    info "Opening SPICE viewer for $vm_name..."
    virt-viewer "$vm_name" &
    disown
    success "Viewer opened"
}

# â”€â”€ GPU Reset (emergency) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

cmd_gpu_reset() {
    print_banner
    header "Emergency GPU Reset"

    load_config
    local gpu_pci="${GPU_PCI:-0000:01:00.0}"
    local gpu_audio="${GPU_AUDIO:-0000:01:00.1}"

    if [ "$EUID" -ne 0 ]; then
        error "GPU reset must be run as root (use sudo)"
        exit 1
    fi

    for dev in $gpu_pci $gpu_audio; do
        local driver
        driver=$(basename "$(readlink "/sys/bus/pci/devices/$dev/driver" 2>/dev/null)" 2>/dev/null)
        info "$dev current driver: ${driver:-none}"

        # Unbind from current driver
        if [ -n "$driver" ]; then
            echo "$dev" > "/sys/bus/pci/devices/$dev/driver/unbind" 2>/dev/null || true
            sleep 0.5
        fi

        # Clear override
        echo "" > "/sys/bus/pci/devices/$dev/driver_override" 2>/dev/null || true
    done

    # Rescan PCI bus
    info "Rescanning PCI bus..."
    echo 1 > /sys/bus/pci/rescan
    sleep 2

    # Reload nvidia
    for mod in nvidia nvidia_modeset nvidia_uvm nvidia_drm; do
        modprobe "$mod" 2>/dev/null || true
    done

    # Explicit rebind if device didn't auto-claim
    sleep 1
    for dev in $gpu_pci $gpu_audio; do
        local driver
        driver=$(basename "$(readlink "/sys/bus/pci/devices/$dev/driver" 2>/dev/null)" 2>/dev/null)
        if [ -z "$driver" ]; then
            info "$dev has no driver â€” attempting explicit bind..."
            for try_driver in nvidia nouveau; do
                if [ -d "/sys/bus/pci/drivers/$try_driver" ]; then
                    if echo "$dev" > "/sys/bus/pci/drivers/$try_driver/bind" 2>/dev/null; then
                        success "$dev explicitly bound to $try_driver"
                        break
                    fi
                fi
            done
            sleep 0.5
            driver=$(basename "$(readlink "/sys/bus/pci/devices/$dev/driver" 2>/dev/null)" 2>/dev/null)
        fi

        if [ -n "$driver" ] && [ "$driver" != "vfio-pci" ]; then
            success "$dev â†’ $driver"
        else
            warn "$dev â†’ ${driver:-no driver}"
        fi
    done

    # Also clean stale QEMU domain directories
    local vm_name="${VM_NAME:-win11-dragonforge}"
    for stale_dir in /var/lib/libvirt/qemu/domain-*-"${vm_name}"; do
        if [ -d "$stale_dir" ]; then
            info "Cleaning stale QEMU state: $stale_dir"
            rm -rf "$stale_dir" 2>/dev/null || true
        fi
    done

    echo ""
}

# â”€â”€ Logs â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

cmd_logs() {
    local log_file="/var/log/dragonforge.log"
    local lines="${1:-50}"

    if [ -f "$log_file" ]; then
        info "Last $lines lines from $log_file:"
        echo ""
        tail -n "$lines" "$log_file"
    else
        info "No log file yet. Logs are created when the VM starts/stops."
    fi

    echo ""
    info "System journal entries:"
    echo ""
    journalctl -t DragonForge --no-pager -n "$lines" 2>/dev/null || info "No journal entries found"
    echo ""
}

# â”€â”€ VM Delete â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

cmd_vm_delete() {
    load_config
    local vm_name="${VM_NAME:-win11-dragonforge}"
    local disk_path="${VM_DISK_PATH:-/var/lib/libvirt/images/${vm_name}.qcow2}"
    local ovmf_vars="/var/lib/libvirt/images/${vm_name}_VARS.fd"

    print_banner
    header "Deleting VM: $vm_name"

    if [ "$EUID" -ne 0 ]; then
        error "VM delete must be run as root (use sudo)"
        exit 1
    fi

    # Stop if running
    local state
    state=$(virsh domstate "$vm_name" 2>/dev/null || echo "undefined")
    if [ "$state" = "running" ] || [ "$state" = "paused" ]; then
        warn "VM is $state â€” destroying first"
        virsh destroy "$vm_name" 2>/dev/null || true
        sleep 2
    fi

    # Get VM UUID for targeted swtpm cleanup before undefining
    local vm_uuid=""
    if virsh dominfo "$vm_name" &>/dev/null; then
        vm_uuid=$(virsh domuuid "$vm_name" 2>/dev/null || true)
    fi

    # Undefine with full cleanup
    if virsh dominfo "$vm_name" &>/dev/null; then
        virsh undefine "$vm_name" --nvram --tpm 2>/dev/null || true
        success "VM undefined"
    else
        info "VM not defined in libvirt"
    fi

    # Remove disk image
    if [ -f "$disk_path" ]; then
        rm -f "$disk_path"
        success "Disk removed: $disk_path"
    fi

    # Remove OVMF VARS
    if [ -f "$ovmf_vars" ]; then
        rm -f "$ovmf_vars"
        success "NVRAM removed: $ovmf_vars"
    fi

    # Remove swtpm state for THIS VM only
    if [ -n "$vm_uuid" ]; then
        local swtpm_dir="/var/lib/libvirt/swtpm"
        if [ -d "$swtpm_dir/$vm_uuid" ]; then
            rm -rf "$swtpm_dir/$vm_uuid"
            success "TPM state cleared ($vm_uuid)"
        fi
    fi

    echo ""
    success "VM '$vm_name' fully deleted"
    info "ISOs preserved â€” only VM artifacts removed"
    info "Run ${BOLD}dragonforge create${NC} to build a new VM"
    echo ""
}

# â”€â”€ Uninstall â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

cmd_uninstall() {
    print_banner
    header "Uninstalling DragonForge"

    if [ "$EUID" -ne 0 ]; then
        error "Uninstall must be run as root (use sudo)"
        exit 1
    fi

    rm -f /etc/libvirt/hooks/qemu
    rm -f /etc/libvirt/hooks/dragonforge.env
    rm -f /etc/modules-load.d/dragonforge-vfio.conf
    rm -f /etc/modprobe.d/dragonforge-vfio.conf
    rm -f /usr/local/bin/dragonforge

    success "Hook removed"
    success "VFIO configs removed"
    success "Symlink removed"
    info "Reboot to fully revert changes"
    echo ""
}

# â”€â”€ Main â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

# Normalize command: strip hyphens so "vmstart" = "vm-start"
CMD=$(echo "${1:-help}" | tr -d '-')

case "$CMD" in
    detect)                 cmd_detect ;;
    setup|install)          cmd_setup ;;
    status)                 cmd_status ;;
    vmcreate|create)        cmd_vm_create ;;
    vmstart|start)          cmd_vm_start ;;
    vmstop|stop)            cmd_vm_stop ;;
    vmkill|kill)            cmd_vm_kill ;;
    vmviewer|viewer)        cmd_vm_viewer ;;
    gpureset|reset)         cmd_gpu_reset ;;
    vmdelete|delete)        cmd_vm_delete ;;
    logs|log)               cmd_logs "${2:-}" ;;
    uninstall|remove)       cmd_uninstall ;;
    version|v)              echo "DragonForge $VERSION" ;;
    help|*)
        print_banner
        echo "  Usage: dragonforge <command>"
        echo ""
        echo "  Commands:"
        echo "    detect      Detect GPU, IOMMU groups, system info"
        echo "    setup       Install hook + configure VFIO (requires sudo)"
        echo "    status      Check passthrough state"
        echo "    create      Create Windows 11 VM from config"
        echo "    start       Start the VM (with pre-flight checks)"
        echo "    stop        Gracefully shut down the VM"
        echo "    kill        Force stop the VM"
        echo "    viewer      Open SPICE viewer"
        echo "    reset       Emergency: return GPU to host (requires sudo)"
        echo "    delete      Delete VM (disk, NVRAM, TPM â€” keeps ISOs)"
        echo "    logs        Show DragonForge log history"
        echo "    uninstall   Remove hook and VFIO config (requires sudo)"
        echo "    version     Show version"
        echo ""
        echo "  Aliases: vm-start, vmstart, start all work. Hyphens are optional."
        echo ""
        ;;
esac
